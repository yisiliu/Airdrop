const BigNumber = require('bignumber.js')
const chai = require('chai')
const expect = chai.expect
chai.use(require('chai-as-promised'))
const AirDrop = artifacts.require("Airdrop")
const Token = artifacts.require("TestTokenA")
const { leavesWithProof, merkleRoot } = require("./generated")
const {
  start_time,
  end_time,
  root_changed_encode,
  root_changed_types,
  claimed_encode,
  claimed_types,
  withdrawed_encode,
  withdrawed_types,
  token_amount
} = require("./constants")
const {
  getEventLogs,
  takeSnapshot,
  revertToSnapShot,
  advanceTimeAndBlock,
  logLatestBlockTimestamp,
  advanceTimeWithLog,
  getRevertMsg,
  getRevertMsg2
} = require("./utils")

let airDrop
let token
let snapShot
let snapshotId

contract("AirDrop", (accounts) => {
  beforeEach(async () => {
    airDrop = await AirDrop.deployed()
    token = await Token.deployed()
    snapShot = await takeSnapshot()
    snapshotId = snapShot['result']
  })

  afterEach(async () => {
    await revertToSnapShot(snapshotId)
  })

  describe('check()', async () => {
    it('should verify root successful with proof generated by typescript', async () => {
      await advanceTimeWithLog(86400 * 9 / 10)
      await check(true)
    })

    it('should failure to verify root after set an unmatched root', async () => {
      await advanceTimeWithLog(86400 * 9 / 10)
      const fakeRoot = '0xe4a6109e00d53b509bac49787d00c85d41ca682e297d029647c8c45db8f8c36f'
      await airDrop.set_root.sendTransaction(fakeRoot)
      const log = await getEventLogs(airDrop.address, root_changed_encode, root_changed_types)
      expect(log).to.have.property('previous').that.to.be.eq(merkleRoot)
      expect(log).to.have.property('now').that.to.be.eq(fakeRoot)
      await check(false)
      await airDrop.set_root.sendTransaction(merkleRoot)
      await check(true)
    })

    it('should not decrease the amount less than one day', async () => {
      const currentBlockTimestamp = await advanceTimeWithLog(86400 * 9 / 10)
      expect(currentBlockTimestamp - start_time).to.be.lessThan(86400)
      await check(true, 1)
    })

    it('should decrease the amount by 20% when one day after start_time', async () => {
      const currentBlockTimestamp = await advanceTimeWithLog(86400 * 10 / 10)
      expect(currentBlockTimestamp - start_time).to.be.lessThan(86400 * 2)
      await check(true, 0.8)
    })

    it('should decrease the amount by 20% after one day after start_time', async () => {
      const currentBlockTimestamp = await advanceTimeWithLog(86400 * 11 / 10)
      expect(currentBlockTimestamp - start_time).to.be.lessThan(86400 * 2).and.to.be.greaterThan(86400)
      await check(true, 0.8)
    })

    it('should decrease the amount by 40% after two days after start_time', async () => {
      const currentBlockTimestamp = await advanceTimeWithLog(86400 * 21 / 10)
      expect(currentBlockTimestamp - start_time).to.be.lessThan(86400 * 3).and.to.be.greaterThan(86400 * 2)
      await check(true, 0.6)
    })

    it('should decrease the amount by 60% after three days after start_time', async () => {
      const currentBlockTimestamp = await advanceTimeWithLog(86400 * 31 / 10)
      expect(currentBlockTimestamp - start_time).to.be.lessThan(86400 * 4).and.to.be.greaterThan(86400 * 3)
      await check(true, 0.4)
    })

    it('should decrease the amount by 80% after four days after start_time', async () => {
      const currentBlockTimestamp = await advanceTimeWithLog(86400 * 41 / 10)
      expect(currentBlockTimestamp - start_time).to.be.lessThan(86400 * 5).and.to.be.greaterThan(86400 * 4)
      await check(true, 0.2)
    })

    it('should decrease the amount by 100% after five days after start_time', async () => {
      const currentBlockTimestamp = await advanceTimeWithLog(86400 * 51 / 10)
      expect(currentBlockTimestamp - start_time).to.be.lessThan(86400 * 6).and.to.be.greaterThan(86400 * 5)
      await checkFail('Expired')
    })

    it('should decrease the amount by 100% after six days after start_time', async () => {
      const currentBlockTimestamp = await advanceTimeWithLog(86400 * 61 / 10)
      expect(currentBlockTimestamp - start_time).to.be.lessThan(86400 * 7).and.to.be.greaterThan(86400 * 6)
      await checkFail('Expired')
    })

    async function check(isAvailable, shrinkRate = 1) {
      for (let i = 0; i < leavesWithProof.length; i++) {
        const leaf = leavesWithProof[i]
        const v = await airDrop.check.call(leaf.index, leaf.address, leaf.amount, leaf.proof)
        expect(v.available).to.be.eq(isAvailable)
        expect(v.start.toString()).to.be.eq(start_time.toString())
        expect(v.end.toString()).to.be.eq(end_time.toString())
        if (!isAvailable) {
          expect(v.claimable.toString()).to.be.eq('0')
        } else {
          expect(v.claimable.toString()).to.be.eq((Math.ceil(leaf.amount * shrinkRate)).toString())
        }
      }
    }

    async function checkFail(reason) {
      for (let i = 0; i < leavesWithProof.length; i++) {
        const leaf = leavesWithProof[i]
        await expect(
          airDrop.check.call(leaf.index, leaf.address, leaf.amount, leaf.proof)
        ).to.be.rejectedWith(getRevertMsg2(reason))
      }
    }
  })

  describe('claim()', async () => {
    it('should failure to claim when Not Started', async () => {
      await claimFail('Not Started')
    })

    it('should failure to claim when Expired', async () => {
      await advanceTimeWithLog(86400 * 100 / 10)
      await claimFail('Expired')
    })

    it('should failure to claim when Not Verified', async () => {
      await advanceTimeWithLog(86400 * 5 / 10)
      await claimFail('Not Verified')
    })

    it('should failure to claim when Already Claimed', async () => {
      await advanceTimeWithLog(86400 * 5 / 10)
      const leaf = leavesWithProof[0]
      await airDrop.claim.sendTransaction(leaf.index, leaf.amount, leaf.proof, { from: leaf.address })
      await expect(
        airDrop.claim.sendTransaction(leaf.index, leaf.amount, leaf.proof, { from: leaf.address })
      ).to.be.rejectedWith(getRevertMsg('Already Claimed'))
    })

    it('should claim 100% amount within one day', async () => {
      await advanceTimeWithLog(86400 * 5 / 10)
      await claim()
    })

    it('should claim 80% amount after one day', async () => {
      await advanceTimeWithLog(86400 * 11 / 10)
      await claim(0.8)
    })

    it('should claim 60% amount after two days', async () => {
      await advanceTimeWithLog(86400 * 21 / 10)
      await claim(0.6)
    })

    it('should claim 40% amount after three days', async () => {
      await advanceTimeWithLog(86400 * 31 / 10)
      await claim(0.4)
    })

    it('should claim 20% amount after four days', async () => {
      await advanceTimeWithLog(86400 * 41 / 10)
      await claim(0.2)
    })

    it('should failure to claim when expired after five days', async () => {
      await advanceTimeWithLog(86400 * 51 / 10)
      await claimFail('Expired')
    })

    it('should failure to claim when expired after six days', async () => {
      await advanceTimeWithLog(86400 * 61 / 10)
      await claimFail('Expired')
    })

    async function claimFail(reason) {
      for (let i = 0; i < leavesWithProof.length; i++) {
        const leaf = leavesWithProof[i]
        await expect(
          airDrop.claim.sendTransaction(
            leaf.index,
            reason === 'Not Verified' ? (Number(leaf.amount) + 1).toString() : leaf.amount,
            leaf.proof,
            { from: leaf.address }
          )
        ).to.be.rejectedWith(getRevertMsg(reason))
      }
    }
  })

  describe('withdraw()', async () => {
    it('should fail when not called by contract creator', async () => {
      await expect(
        airDrop.withdraw.sendTransaction({ from: accounts[2] })
      ).to.be.rejectedWith(getRevertMsg('Not Authorized'))
    })

    it('should fail when not Not Expired', async () => {
      await expect(
        airDrop.withdraw.sendTransaction({ from: accounts[0] })
      ).to.be.rejectedWith(getRevertMsg('Not Expired'))
    })

    it('should withdraw successful after Expired', async () => {
      await advanceTimeWithLog(86400 * 5 / 10)
      const claimed_amount = BigNumber(await claim()).times(10 ** 18)
      await advanceTimeWithLog(86400 * 100)
      await airDrop.withdraw.sendTransaction({ from: accounts[0] })
      const log = await getEventLogs(airDrop.address, withdrawed_encode, withdrawed_types)
      expect(log).to.have.property('left').that.to.be.eq(
        BigNumber(token_amount).minus(claimed_amount).toFixed()
      )
      console.log(`     üê¶ withdrawed amount: ${log.left}`)
      console.log(`     üê¶ claimed amount: ${claimed_amount.toFixed()}`)
    })
  })

  async function claim(shrinkRate = 1) {
    let claimed_amount = 0
    for (let i = 0; i < leavesWithProof.length; i++) {
      const leaf = leavesWithProof[i]
      await airDrop.claim.sendTransaction(leaf.index, leaf.amount, leaf.proof, { from: leaf.address })
      const balance = await token.balanceOf.call(leaf.address)
      claimed_amount += leaf.amount * shrinkRate
      expect(BigNumber(balance.toString()).div(1e18).toFixed(2)).to.be.eq(
        (leaf.amount * shrinkRate).toFixed(2)
      )
    }
    const logs = await getEventLogs(airDrop.address, claimed_encode, claimed_types, leavesWithProof.length)
    logs.forEach(async (log, i) => {
      const leaf = leavesWithProof[i]
      expect(BigNumber(log.amount).div(1e18).toFixed(2)).to.be.eq(
        (leaf.amount * shrinkRate).toFixed(2)
      )
    })
    return claimed_amount
  }
})
